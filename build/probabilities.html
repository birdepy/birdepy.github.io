<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Transition Probabilities &mdash; BirDePy 0.0.10 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/Birdepy_favicon_3.png"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=d019515e"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parameter Estimation" href="estimation.html" />
    <link rel="prev" title="Simulation Algorithms" href="simulation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="index.html">
            
              <img src="_static/Birdepy_logo_1_resized.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Theoretical Background</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="processes.html">Birth-and-death Processes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="processes.html#custom-models">Custom Models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="simulation.html">Simulation Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#exact">Exact</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#tau-leaping"><span class="math notranslate nohighlight">\(\tau\)</span> leaping</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#midpoint-approximation">Midpoint approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#galton-watson-approximation">Galton–Watson approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#summary">Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#reproducibility">Reproducibility</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Transition Probabilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#matrix-exponential">Matrix exponential</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uniformization">Uniformization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#erlangization">Erlangization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inverse-laplace-transform">Inverse Laplace transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diffusion-approximation">Diffusion approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ornstein-uhlenbeck-approximation">Ornstein–Uhlenbeck approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#galton-watson-approximation">Galton–Watson approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulation">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="estimation.html">Parameter Estimation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#direct-numerical-maximization">Direct Numerical Maximization</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#expectation-maximization">Expectation Maximization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="estimation.html#expectation-step-techniques">Expectation Step Techniques</a></li>
<li class="toctree-l3"><a class="reference internal" href="estimation.html#acceleration">Acceleration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#least-squares-estimation">Least Squares Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#approximate-bayesian-computation">Approximate Bayesian Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="estimation.html#customized-distance">Customized Distance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#known-parameters">Known Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#parameter-constraints">Parameter Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#confidence-regions">Confidence Regions</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#continuously-observed-data">Continuously Observed Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#optimization-options">Optimization Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="forecasting.html">Forecasting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Core Functions API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_probability.html">birdepy.probability()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy.probability"><code class="docutils literal notranslate"><span class="pre">probability()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-da">birdepy.probability(method=’da’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_da.probability_da"><code class="docutils literal notranslate"><span class="pre">probability_da()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-erlang">birdepy.probability(method=’Erlang’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_Erlang.probability_Erlang"><code class="docutils literal notranslate"><span class="pre">probability_Erlang()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-expm">birdepy.probability(method=’expm’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_expm.probability_expm"><code class="docutils literal notranslate"><span class="pre">probability_expm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-gwa">birdepy.probability(method=’gwa’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_gwa.probability_gwa"><code class="docutils literal notranslate"><span class="pre">probability_gwa()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-gwasa">birdepy.probability(method=’gwasa’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_gwasa.probability_gwasa"><code class="docutils literal notranslate"><span class="pre">probability_gwasa()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-ilt">birdepy.probability(method=’ilt’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_ilt.probability_ilt"><code class="docutils literal notranslate"><span class="pre">probability_ilt()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-oua">birdepy.probability(method=’oua’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_oua.probability_oua"><code class="docutils literal notranslate"><span class="pre">probability_oua()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-sim">birdepy.probability(method=’sim’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_sim.probability_sim"><code class="docutils literal notranslate"><span class="pre">probability_sim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-uniform">birdepy.probability(method=’uniform’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_uniform.probability_uniform"><code class="docutils literal notranslate"><span class="pre">probability_uniform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_estimate.html">birdepy.estimate()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy.estimate"><code class="docutils literal notranslate"><span class="pre">estimate()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-abc">birdepy.estimate(framework=’abc’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_abc.discrete_est_abc"><code class="docutils literal notranslate"><span class="pre">discrete_est_abc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-dnm">birdepy.estimate(framework=’dnm’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_dnm.discrete_est_dnm"><code class="docutils literal notranslate"><span class="pre">discrete_est_dnm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-em">birdepy.estimate(framework=’em’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_em.discrete_est_em"><code class="docutils literal notranslate"><span class="pre">discrete_est_em()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-lse">birdepy.estimate(framework=’lse’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_lse.discrete_est_lse"><code class="docutils literal notranslate"><span class="pre">discrete_est_lse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-scheme-continuous">birdepy.estimate(scheme=’continuous’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_dnm.continuous_est_dnm"><code class="docutils literal notranslate"><span class="pre">continuous_est_dnm()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_simulate_discrete.html">birdepy.simulate.discrete()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_simulate_discrete.html#birdepy.simulate.discrete"><code class="docutils literal notranslate"><span class="pre">discrete()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_simulate_continuous.html">birdepy.simulate.continuous()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_simulate_continuous.html#birdepy.simulate.continuous"><code class="docutils literal notranslate"><span class="pre">continuous()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_forecast.html">birdepy.forecast()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_forecast.html#birdepy.forecast"><code class="docutils literal notranslate"><span class="pre">forecast()</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">CUDA Functions API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_cuda_simulate.html">birdepy.gpu_functions.discrete()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_cuda_simulate.html#birdepy.gpu_functions.discrete"><code class="docutils literal notranslate"><span class="pre">discrete()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_cuda_probabilities.html">birdepy.gpu_functions.probability()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_cuda_probabilities.html#birdepy.gpu_functions.probability"><code class="docutils literal notranslate"><span class="pre">probability()</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Bug Reports and Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id1">0.0.12</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id2">0.0.11</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id3">0.0.10</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id4">0.0.9</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id5">0.0.8</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id6">0.0.7</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id7">0.0.6</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id8">0.0.5</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id9">0.0.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id10">0.0.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id11">0.0.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id12">0.0.1</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BirDePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Transition Probabilities</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/probabilities.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="transition-probabilities">
<h1>Transition Probabilities<a class="headerlink" href="#transition-probabilities" title="Permalink to this heading"></a></h1>
<p>Many of the <a class="reference internal" href="processes.html#birth-and-death-processes"><span class="std std-ref">general models implemented in Birdepy</span></a> have
no explicit expression for their transition probabilities
<span class="math notranslate nohighlight">\(p_{i,j}(t) := \mathbb P(Z(t)=j\mid Z(0)=i)\)</span>, <span class="math notranslate nohighlight">\(i,j\in \mathcal S\)</span>, <span class="math notranslate nohighlight">\(t\geq 0\)</span>.
However, it is often desirable to compute these transition probabilities since they allow for a deeper understanding of the future (random) evolution of the process.
Practically speaking, this may underpin some performance analysis of a system which is being modelled by the process.
Additionally, transition probabilities allow likelihood functions of discretely-observed sample paths to be evaluated, which opens up the possibility of parameter estimation (as discussed in the next section).
This page outlines nine methods of approximating <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span>, as implemented in <a class="reference internal" href="api_probability.html#birdepy-probability"><span class="std std-ref">birdepy.probability()</span></a>.
Three of these methods are matrix-based and rely on state space truncation, another method uses Laplace transforms, and the remaining four methods use approximation models.</p>
<p>To obtain transition probabilities in BirDePy simply call <a class="reference internal" href="api_probability.html#birdepy-probability"><span class="std std-ref">birdepy.probability()</span></a> (after importing BirDePy). For example, to obtain an array containing the probabilities of transitioning from <span class="math notranslate nohighlight">\(Z(0)=20\)</span> to <span class="math notranslate nohighlight">\(Z(1)=25\)</span> for the ‘Verhulst’ model with <span class="math notranslate nohighlight">\(\boldsymbol \theta = (0.8, 0.4, 0.01, 0.001)\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">birdepy</span> <span class="k">as</span> <span class="nn">bd</span>
<span class="n">bd</span><span class="o">.</span><span class="n">probability</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">],</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Verhulst&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;expm&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Which returns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span><span class="mf">0.08189476</span><span class="p">]])</span>
</pre></div>
</div>
<p>The method ‘expm’ can be replaced by one of the nine choices described on this page.
Note that output is an array since it is possible to input initial and final population sizes as lists.</p>
<section id="matrix-exponential">
<h2>Matrix exponential<a class="headerlink" href="#matrix-exponential" title="Permalink to this heading"></a></h2>
<p>The Kolmogorov forward equation for CTMCs provides the foundational property that the collection of transition probability functions <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span> satisfy, for <span class="math notranslate nohighlight">\(t\ge0\)</span>, the system of first order ordinary differential equations</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\frac{ d p_{i,0}(t)}{d t} &amp;= \mu_1 p_{i,1}(t) - \lambda_0p_{i,0}(t),\\
\frac{ d p_{i,j}(t)}{d t} &amp;= \lambda_{j-1}p_{i,j-1}(t) + \mu_{j+1}p_{i,j+1}(t)- (\lambda_j+\mu_j)p_{i,j}(t), \quad j\ge 1,\\\end{split}\]</div>
</div></blockquote>
<p>with <span class="math notranslate nohighlight">\(p_{i,i}(0) = 1\)</span> and <span class="math notranslate nohighlight">\(p_{i,j}(0)=0\)</span> for <span class="math notranslate nohighlight">\(j\ne i\)</span>.
Let <span class="math notranslate nohighlight">\(Q\)</span> be the <em>generator</em> of <span class="math notranslate nohighlight">\(Z\)</span>, that is, the square matrix with diagonal entries <span class="math notranslate nohighlight">\(q_{i,i}=-(\lambda_i+\mu_i)\)</span>, upper diagonal entries <span class="math notranslate nohighlight">\(q_{i,i+1}=\lambda_i\)</span>, and lower diagonal entries <span class="math notranslate nohighlight">\(q_{i-1,i}=\mu_i\)</span> (and zeros elsewhere).
Also collect the transition probabilities into a matrix <span class="math notranslate nohighlight">\(P(t) = \big(p_{i,j}(t); i,j\in\mathcal S\big)\)</span>.
Then the equation above can be written in matrix form as <span class="math notranslate nohighlight">\(\frac{d}{d t} P(t) = P(t)Q\)</span>.
When <span class="math notranslate nohighlight">\(Q\)</span> is finite it immediately follows that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[P(t) = \lim_{k\to\infty}\sum_{n=0}^k \frac{1}{n!}(Qt)^{n} =: \exp(Qt).\]</div>
</div></blockquote>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-expm"><span class="std std-ref">birdepy.probability(method=’expm’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="uniformization">
<h2>Uniformization<a class="headerlink" href="#uniformization" title="Permalink to this heading"></a></h2>
<p>Due to the special nature of the generator <span class="math notranslate nohighlight">\(Q\)</span> (specifically that it has non-negative off-diagonal entries and row-sums equal to 0), an alternative procedure known as <em>uniformization</em>, introduced by <a class="reference internal" href="#jensen1953" id="id1"><span>[Jensen1953]</span></a>, is available for computing <span class="math notranslate nohighlight">\(P(t)\)</span>.
Consider a discrete-time Markov chain (DTMC) with probability transition matrix <span class="math notranslate nohighlight">\(A:=Q/a+I\)</span>, where <span class="math notranslate nohighlight">\(a:=\max_z |\lambda_z+\mu_z|\)</span> when this exists (for example when <span class="math notranslate nohighlight">\(|\mathcal S|&lt;\infty\)</span>), and where <span class="math notranslate nohighlight">\(I\)</span> denotes the identity matrix of appropriate size.
Suppose that this DTMC transitions at the event times of a Poisson process <span class="math notranslate nohighlight">\((N(t),~t\ge0)\)</span> with rate <span class="math notranslate nohighlight">\(a\)</span>.
Using this construction, we can show that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbb P(Z(t)=j\mid Z(0)=i, N(t)=n)=(A^n)_{i,j}.\]</div>
</div></blockquote>
<p>Therefore, conditioning on <span class="math notranslate nohighlight">\(N(t)\)</span> provides</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[P(t) = \lim_{k\to\infty}\sum_{n=0}^k \frac{(ta)^ne^{-ta}}{n!} A^n.\]</div>
</div></blockquote>
<p>In addition to potentially requiring truncation of the state space for many models of interest, another source of approximation error for this method is that a finite <span class="math notranslate nohighlight">\(k\)</span> must be chosen in the above infinite series.</p>
<p>This method is discussed at length in <a class="reference internal" href="#grassman1977" id="id2"><span>[Grassman1977]</span></a> and <a class="reference internal" href="#vandijketal2018" id="id3"><span>[vanDijkEtAl2018]</span></a>.</p>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-uniform"><span class="std std-ref">birdepy.probability(method=’uniform’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="erlangization">
<h2>Erlangization<a class="headerlink" href="#erlangization" title="Permalink to this heading"></a></h2>
<p>Using probabilistic arguments, <em>Erlangization</em> is yet another matrix-based method for computing <span class="math notranslate nohighlight">\(P(t)\)</span>.
Let <span class="math notranslate nohighlight">\(T\)</span> be an exponentially distributed random variable with mean <span class="math notranslate nohighlight">\(\eta^{-1}&gt;0\)</span>.
Define <span class="math notranslate nohighlight">\(r^{(\eta)}_{i,j} := \mathbb P(Z(T) = j\mid Z(0)= i)\)</span> and collect these quantities into  <span class="math notranslate nohighlight">\(R(\eta) = \big(r^{(\eta)}_{i,j},~i,j\in \mathcal S)\)</span>.
The matrix <span class="math notranslate nohighlight">\(R(\eta)\)</span> can be viewed as the one-step transition probability matrix of a DTMC embedded in <span class="math notranslate nohighlight">\(Z\)</span> at the epochs of a Poisson process with rate <span class="math notranslate nohighlight">\(\eta\)</span>.
By conditioning on the first transition of <span class="math notranslate nohighlight">\(Z\)</span> and the expiry of the time <span class="math notranslate nohighlight">\(T\)</span>, we obtain the recursive expressions</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[r^{(\eta)}_{i,j}= \frac{\mu_ir^{(\eta)}_{i-1,j} + \lambda_ir^{(\eta)}_{i+1,j} + \eta 1_{\{i=j\}}}{\lambda_i + \mu_i + \eta},\quad i,j\in\mathcal S.\]</div>
</div></blockquote>
<p>This system of equations can be written in matrix form in terms of <span class="math notranslate nohighlight">\(R(\eta)\)</span>, whose solution is given in terms of the generator <span class="math notranslate nohighlight">\(Q\)</span> by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[R(\eta) = \eta\big(\eta I-Q)\big)^{-1}.\]</div>
</div></blockquote>
<p>Therefore, if we let <span class="math notranslate nohighlight">\(\eta:=k/t\)</span> and <span class="math notranslate nohighlight">\(S_{k,t}\)</span> be an Erlang distributed random variable with rate parameter <span class="math notranslate nohighlight">\(k/t\)</span> and shape parameter <span class="math notranslate nohighlight">\(k\)</span>, then the <span class="math notranslate nohighlight">\((i,j)`th entry of the matrix :math:`R(k/t)^k\)</span> contains <span class="math notranslate nohighlight">\(\mathbb P(Z(S_{k,t})=j\mid Z(0)=i)\)</span>.
The expected value of <span class="math notranslate nohighlight">\(S_{k,t}\)</span> is <span class="math notranslate nohighlight">\(t\)</span> and the variance of <span class="math notranslate nohighlight">\(S_{k,t}\)</span> is <span class="math notranslate nohighlight">\(t/k\)</span>.
This means that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[P(t) = \lim_{k\to\infty}R(k/t)^k.\]</div>
</div></blockquote>
<p>The Erlangization method for approximating transition probabilities is discussed in <a class="reference internal" href="#asmussenetal2002" id="id4"><span>[AsmussenEtAl2002]</span></a>, <a class="reference internal" href="#mandjestaylor2016" id="id5"><span>[MandjesTaylor2016]</span></a> and <a class="reference internal" href="#stanfordetal2011" id="id6"><span>[StanfordEtAl2011]</span></a> for models related to birth-and-death processes.
Similar to the uniformization method, error arises in the Erlangization method since the state space may need to be truncated, and the infinite limit above needs to be approximated by a finite <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-erlang"><span class="std std-ref">birdepy.probability(method=’Erlang’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="inverse-laplace-transform">
<h2>Inverse Laplace transform<a class="headerlink" href="#inverse-laplace-transform" title="Permalink to this heading"></a></h2>
<p>The Laplace transform of the transition function <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span> is</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[f_{i,j}(s) = \mathcal L[p_{i,j}](s) = \int_0^\infty p_{i,j}(t)e^{-st} d t.\]</div>
</div></blockquote>
<p>Let <span class="math notranslate nohighlight">\(\frac{u_1}{v_1+}\frac{u_2}{v_2+}\frac{u_3}{v_3+}\cdots\)</span> be a short-hand notation for the <em>continued fraction</em></p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\dfrac{u_1}{v_1+\dfrac{u_2}{v_2+\dfrac{u_3}{v_3 +\cdots }}},\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\((u_i,~i=1,2,\dots)\)</span> and <span class="math notranslate nohighlight">\((v_i,~i=1,2,\dots)\)</span> are sequences of real numbers.
As first reported in <a class="reference internal" href="#murphy1975" id="id7"><span>[Murphy1975]</span></a> and detailed in <a class="reference internal" href="#crawfordsuchard2012" id="id8"><span>[CrawfordSuchard2012]</span></a>, the Laplace transform takes the continued fraction form</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}f_{i,j}(s) = \left\{ \begin{array}{ll}
\left(\prod_{k=j+1}^i\mu_k\right)\frac{B_j(s)}{B_{i+1}(s)+}\frac{B_i(s)\,a_{i+2}}{b_{i+2}(s)+}\frac{a_{i+3}}{b_{i+3}(s)+}\cdots, &amp; \text{for } j \le i,\\[0.5em]
\left(\prod_{k=i}^{j-1}\lambda_k\right) \frac{B_i(s)}{B_{j+1}(s)+}\frac{B_j(s)\,a_{j+1}}{b_{j+2}(s)+}\frac{a_{j+3}}{b_{j+3}(s)+}\cdots, &amp; \text{for } j \ge i,
\end{array}\right.\end{split}\]</div>
</div></blockquote>
<p>where</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}B_0(s)&amp;=1,\\
B_1(s)&amp;=b_1(s),\quad\text{and}\\
B_k(s)&amp;=b_k(s)B_{k-1}(s)+a_kB_{k-2}(s),\quad\text{for } k\ge 2,\end{split}\]</div>
</div></blockquote>
<p>with <span class="math notranslate nohighlight">\(a_1=1\)</span> and <span class="math notranslate nohighlight">\(a_j = -\lambda_{j-2}{\mu_{j-1}}\)</span> for <span class="math notranslate nohighlight">\(j\ge2\)</span>, and <span class="math notranslate nohighlight">\(b_1(s)=s+\lambda_0\)</span> and <span class="math notranslate nohighlight">\(b_j(s)=s+\lambda_{j-1}+\mu_{j-1}\)</span> for <span class="math notranslate nohighlight">\(j\ge2\)</span>.
An advantage of the continued fraction form is that it can be evaluated using the Lentz algorithm to a user-specified error tolerance.
The Laplace transform can then be numerically inverted to obtain <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span>.</p>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-ilt"><span class="std std-ref">birdepy.probability(method=’ilt’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="diffusion-approximation">
<h2>Diffusion approximation<a class="headerlink" href="#diffusion-approximation" title="Permalink to this heading"></a></h2>
<p>Define <span class="math notranslate nohighlight">\((Z_i^{(r)},~r \in\mathbb N)\)</span> to be a parametric family of CTMCs which evolve according to transition rates <span class="math notranslate nohighlight">\(\lambda_z^{(r)} = r\lambda_{z/r}\)</span> and <span class="math notranslate nohighlight">\(\mu_z^{(r)} = r\mu_{z/r}\)</span> with <span class="math notranslate nohighlight">\(Z_i^{(r)}(0)=i\)</span>.
For <span class="math notranslate nohighlight">\(s \in[0, t]\)</span> define the diffusion-scaled process</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\tilde Z_i(s) = \lim_{r\to\infty}\sqrt{r}\left(\hat Z_i^{(r)}(s) - \hat z_i(s)\right),\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\hat Z_i^{(r)}:=\frac{1}{r} Z_i^{(r)}(s)\)</span> and <span class="math notranslate nohighlight">\(\hat z_i(s)\)</span> satisfies</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{ d }{d s}\hat z_i(s) = \lambda_{\hat z_i(s)} - \mu_{\hat z_i(s)},\qquad \hat z_i(0) = i.\]</div>
</div></blockquote>
<p>Loosely speaking, Theorem~3.5 in <a class="reference internal" href="#kurtz1971" id="id9"><span>[Kurtz1971]</span></a> can be used to show that, under some regularity conditions, <span class="math notranslate nohighlight">\((\hat Z_i^{(r)}(s),~s\in[0,t])\)</span> converges weakly, as <span class="math notranslate nohighlight">\(r\to\infty\)</span>, in the space of cadlag functions on <span class="math notranslate nohighlight">\([0, t]\)</span> to a zero-mean Gaussian diffusion <span class="math notranslate nohighlight">\((\tilde Z_i(s),~s\in[0,t])\)</span> with variance</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\sigma_i^2(s) := \text{Var}(\tilde Z(s)) = M(s)^2\int_0^s \left(\lambda_{\hat z(\tau)} + \mu_{\hat z(\tau)}\right) M(\tau)^{-2} d \tau\]</div>
</div></blockquote>
<p>for each <span class="math notranslate nohighlight">\(s\in[0, t]\)</span>,
where <span class="math notranslate nohighlight">\(M(s):= \exp\left(\int_0^s B(\tau)d \tau\right)\)</span> with <span class="math notranslate nohighlight">\(B(\tau) = H\left(\hat z(\tau)\right)\)</span> defined in terms of</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[H(z) = \frac{d}{d z}\Big(\lambda_z - \mu_z\Big).\]</div>
</div></blockquote>
<p>In particular this implies that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[p_{i,j}(t) \approx \mathbb P(\tilde Z_i(t)=j).\]</div>
</div></blockquote>
<p>Hence <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span> can be approximated by the probability density of a normally distributed random variable with mean <span class="math notranslate nohighlight">\(\hat z_i(t)\)</span> and variance <span class="math notranslate nohighlight">\(\sigma_i^2(t)\)</span> as given above.</p>
<p>This approach is very closely related to the functional central limit theorem.
The diffusion approach to approximate transition probabilities is used in <a class="reference internal" href="#rossetal2009" id="id10"><span>[RossEtAl2009]</span></a>, and discussed at length in <a class="reference internal" href="#allen2008" id="id11"><span>[Allen2008]</span></a>.</p>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-da"><span class="std std-ref">birdepy.probability(method=’da’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="ornstein-uhlenbeck-approximation">
<h2>Ornstein–Uhlenbeck approximation<a class="headerlink" href="#ornstein-uhlenbeck-approximation" title="Permalink to this heading"></a></h2>
<p>The diffusion approximation discussed above can be substantially simplified if it is assumed that <span class="math notranslate nohighlight">\(Z\)</span> is fluctuating about a steady state point <span class="math notranslate nohighlight">\(z_{\text{eq}}\)</span> of <span class="math notranslate nohighlight">\(\hat z\)</span>.
Such a point occurs when the birth rate is equal to the death rate, i.e., <span class="math notranslate nohighlight">\(z_{\text{eq}}\)</span> satisfies <span class="math notranslate nohighlight">\(\lambda_{z_{\text{eq}}} = \mu_{z_{\text{eq}}}\)</span>.
In this case, as argued in <a class="reference internal" href="#rossetal2006" id="id12"><span>[RossEtAl2006]</span></a>, the limiting Gaussian diffusion is an Ornstein–Uhlenbeck process.
Therefore, <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span> can be approximated by the density of a normally distributed random variable with mean <span class="math notranslate nohighlight">\(\tilde z= z_{\text{eq}} + e^{H(z_{\text{eq}})t}(i - z_{\text{eq}})\)</span> and variance <span class="math notranslate nohighlight">\(\tilde\sigma^2 = \frac{\lambda_{z_{\text{eq}}} + \mu_{z_{\text{eq}}}}{2H(z_{\text{eq}})}\left(e^{2H(z_{\text{eq}})t}-1\right)\)</span>.
This method assumes that <span class="math notranslate nohighlight">\(z_{\text{eq}}\)</span> is asymptotically stable (i.e., <span class="math notranslate nohighlight">\(H(z_{\text{eq}})&lt;0\)</span>), and as such favors values of <span class="math notranslate nohighlight">\(z_{\text{eq}}\)</span> that minimize <span class="math notranslate nohighlight">\(H(z_{\text{eq}})\)</span>.</p>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-oua"><span class="std std-ref">birdepy.probability(method=’oua’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="galton-watson-approximation">
<h2>Galton–Watson approximation<a class="headerlink" href="#galton-watson-approximation" title="Permalink to this heading"></a></h2>
<p>A PSDBDP can be approximated by a piecewise-linear birth-and-death process by decomposing time into sub-intervals of finite length, and letting the per-individual birth and death rates be constant over each time interval; more precisely, if <span class="math notranslate nohighlight">\(z\)</span> is the population size at the beginning of a time interval, then we let <span class="math notranslate nohighlight">\(\lambda := \frac{1}{z}\lambda_{z}\)</span> and <span class="math notranslate nohighlight">\(\mu := \frac{1}{z}\mu_{z}\)</span> over that interval.</p>
<p>Suppose we want to approximate <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span> for some <span class="math notranslate nohighlight">\(i,j\in\mathcal{S}\)</span> and <span class="math notranslate nohighlight">\(t&gt; 0\)</span>. Consider a linear birth-and-death process <span class="math notranslate nohighlight">\(\mathring Z^{(b)}\)</span> with per-individual birth rate <span class="math notranslate nohighlight">\(\lambda = \frac{1}{b}\lambda_{b}\)</span> and per-individual death rate <span class="math notranslate nohighlight">\(\mu = \frac{1}{b}\mu_{b}\)</span>, where possible choices of <span class="math notranslate nohighlight">\(b\)</span> include <span class="math notranslate nohighlight">\(b=i\)</span>, <span class="math notranslate nohighlight">\(b=j\)</span>, <span class="math notranslate nohighlight">\(b=\max(i,j)\)</span>, <span class="math notranslate nohighlight">\(b=\min(i,j)\)</span>, and <span class="math notranslate nohighlight">\(b=(i+j)/2\)</span>.
The transition probability <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span> can then be approximated by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[p_{i,j}(t) \approx \mathring p_{i,j}(t) :=\mathbb P(\mathring Z^{(b)}(t)=j\mid \mathring Z^{(b)}(0)=i).\]</div>
</div></blockquote>
<p>What constitutes a good choice of <span class="math notranslate nohighlight">\(b\)</span> will depend highly on <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> and the model under study.
This approximation is particularly convenient since it is well known (see <a class="reference internal" href="#guttorp1991" id="id13"><span>[Guttorp1991]</span></a>) that <span class="math notranslate nohighlight">\(\mathring p_{i,0}(t) = \beta_1(t)^{i}\)</span>, and for <span class="math notranslate nohighlight">\(j\ge1\)</span>,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathring p_{i,j}(t) = \sum_{k=\max(0, i-j)}^{i-1} \binom{i}{k} \binom{j -1}{i-k-1} \beta_{1}(t)^k\Big[\big\{1-\beta_{1}(t)\big\}\big\{1-\beta_{2}(t)\big\}\Big]^{j-k} \beta_{2}(t)^{j-i+k},\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\beta_1(t)\)</span> and <span class="math notranslate nohighlight">\(\beta_2(t)\)</span> are given by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\beta_1(t) = \left\{\begin{array}{cc} \mu\{\exp\big((\lambda-\mu)t\big)-1\}/\{\lambda \exp\big((\lambda-\mu)t\big)-\mu\} &amp; \text{if } \lambda\ne \mu, \\
\lambda t/(1+\lambda t) &amp; \text{if } \lambda = \mu.
\end{array}\right.\end{split}\]</div>
</div></blockquote>
<p>and</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\beta_2(t) = \left\{ \begin{array}{cc} \lambda\beta_1(t)/\mu&amp; \text{if } \lambda\ne \mu, \\
\beta_1(\tau) &amp; \text{if } \lambda = \mu.
\end{array}\right.\end{split}\]</div>
</div></blockquote>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-gwa"><span class="std std-ref">birdepy.probability(method=’gwa’)</span></a> for the implementation of this method in BirDePy.</p>
<p>When the binomial coefficients above cause numerical problems or take a long time to compute, an alternative expression developed by <a class="reference internal" href="#davisonetal2021" id="id14"><span>[DavisonEtAl2021]</span></a> using a saddlepoint approximation <a class="reference internal" href="#butler2007" id="id15"><span>[Butler2007]</span></a> may be used. See <a class="reference internal" href="api_probability.html#birdepy-probability-method-gwasa"><span class="std std-ref">birdepy.probability(method=’gwasa’)</span></a> for the implementation of this method in BirDePy.</p>
</section>
<section id="simulation">
<h2>Simulation<a class="headerlink" href="#simulation" title="Permalink to this heading"></a></h2>
<p>Using <a class="reference internal" href="api_simulate_discrete.html#birdepy.simulate.discrete" title="birdepy.simulate.discrete"><code class="xref py py-func docutils literal notranslate"><span class="pre">birdepy.simulate.discrete()</span></code></a> or <a class="reference internal" href="api_cuda_simulate.html#birdepy.gpu_functions.discrete" title="birdepy.gpu_functions.discrete"><code class="xref py py-func docutils literal notranslate"><span class="pre">birdepy.gpu_functions.discrete()</span></code></a> it is possible to obtain <span class="math notranslate nohighlight">\(k\)</span> realizations of <span class="math notranslate nohighlight">\(Z(t)\)</span> conditional on <span class="math notranslate nohighlight">\(Z(0)=i\)</span>.
The proportion of these realisations which equal <span class="math notranslate nohighlight">\(j\)</span> can be used to approximate the transition probability <span class="math notranslate nohighlight">\(p_{i,j}(t)\)</span>. That is,</p>
<div class="math notranslate nohighlight">
\[p_{i,j}(t) \approx \frac{1}{k}\sum_{n=1}^k 1_{\{\hat Z_n(t)=j\}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat Z_l(t)\)</span> are simulated realisations of <span class="math notranslate nohighlight">\(Z(t)\)</span> and <span class="math notranslate nohighlight">\(I_{\{A\}}\)</span> evaluates to 1 when <span class="math notranslate nohighlight">\(A\)</span> is true and otherwise evaluates to 0.</p>
<p>See <a class="reference internal" href="api_probability.html#birdepy-probability-method-sim"><span class="std std-ref">birdepy.probability(method=’sim’)</span></a> and <a class="reference internal" href="api_cuda_probabilities.html#birdepy-gpu-functions-probability"><span class="std std-ref">birdepy.gpu_functions.probability()</span></a> for the implementations of this method in BirDePy.</p>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading"></a></h2>
<p>The table below summarizes methods described on this page, and gives the label used to call them in <a class="reference internal" href="api_estimate.html#birdepy-estimate"><span class="std std-ref">birdepy.estimate()</span></a>.</p>
<table class="docutils align-default" id="id17">
<caption><span class="caption-text">Methods for computing transition probabilities.</span><a class="headerlink" href="#id17" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Label</p></th>
<th class="head"><p>Brief description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Matrix exponential</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'expm'</span></code></p></td>
<td><p>Uses <span class="math notranslate nohighlight">\(P(t)=\exp(Qt)\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p>Uniformization</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'uniform'</span></code></p></td>
<td><p>Evaluates probability using an approximating discrete-time process.</p></td>
</tr>
<tr class="row-even"><td><p>Erlangization</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'Erlang'</span></code></p></td>
<td><p>Evaluates probability at an Erlang-distributed time.</p></td>
</tr>
<tr class="row-odd"><td><p>Inverse Laplace transform</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'ilt'</span></code></p></td>
<td><p>Numerically inverts Laplace transform.</p></td>
</tr>
<tr class="row-even"><td><p>Diffusion approx.</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'da'</span></code></p></td>
<td><p>Approx. true model by a general diffusion-scaled model.</p></td>
</tr>
<tr class="row-odd"><td><p>Ornstein–Uhlenbeck approx.</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'oua'</span></code></p></td>
<td><p>Approx.true model by a simple diffusion process.</p></td>
</tr>
<tr class="row-even"><td><p>Galton–Watson approximation</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'gwa'</span></code></p></td>
<td><p>Approx.~true model with a linear model.</p></td>
</tr>
<tr class="row-odd"><td><p>Saddlepoint approximation</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'gwasa'</span></code></p></td>
<td><p>As above combined with a saddlepoint approx</p></td>
</tr>
<tr class="row-even"><td><p>Simulation</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'sim'</span></code></p></td>
<td><p>Average of Monte Carlo samples.</p></td>
</tr>
</tbody>
</table>
<p>These methods are also described in detail in <a class="reference internal" href="simulation.html#hautphennepatch2021a" id="id16"><span>[HautphennePatch2021a]</span></a>, which can be downloaded <a class="reference external" href="https://github.com/birdepy/paper/blob/main/birdepy.pdf">here</a>. If you use BirDePy for published research, then please cite this paper.</p>
<div role="list" class="citation-list">
<div class="citation" id="grassman1977" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Grassman1977</a><span class="fn-bracket">]</span></span>
<p>Grassman, W., 1977. Transient solutions in Markovian queues. <em>European Journal of Operations Research</em>, 1(6):396–402.</p>
</div>
<div class="citation" id="vandijketal2018" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">vanDijkEtAl2018</a><span class="fn-bracket">]</span></span>
<p>van Dijk, N. M., van Brummelen, S. P. J., &amp; Boucherie, R. J. (2018). Uniformization: Basics, extensions and applications. <em>Performance evaluation</em>, 118, 8-32.</p>
</div>
<div class="citation" id="jensen1953" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Jensen1953</a><span class="fn-bracket">]</span></span>
<p>Jensen, A. (1953). Markoff chains as an aid in the study of Markoff processes. <em>Scandinavian Actuarial Journal</em>, 1953(sup1), 87-91.</p>
</div>
<div class="citation" id="asmussenetal2002" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">AsmussenEtAl2002</a><span class="fn-bracket">]</span></span>
<p>Asmussen, S., Avram, F. and Usabel, M., 2002. Erlangian approximations for finite-horizon ruin probabilities, <em>ASTIN Bulletin: The Journal of the IAA</em>, 32(2)267–281.</p>
</div>
<div class="citation" id="mandjestaylor2016" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">MandjesTaylor2016</a><span class="fn-bracket">]</span></span>
<p>Mandjes, M. and Taylor, P., 2016. The running maximum of a level-dependent quasi-birth-death process, <em>Probability in the Engineering and Informational Sciences</em>, 30(2):212–223.</p>
</div>
<div class="citation" id="stanfordetal2011" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">StanfordEtAl2011</a><span class="fn-bracket">]</span></span>
<p>Stanford, D.A., Yu, K. and Ren, J., 2011. Erlangian approximation to finite time ruin probabilities in perturbed risk models, <em>Scandinavian Actuarial Journal</em>, 2011(1):38–58.</p>
</div>
<div class="citation" id="murphy1975" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">Murphy1975</a><span class="fn-bracket">]</span></span>
<p>Murhy, J. A., &amp; O’donohoe, M. R. (1975). Some properties of continued fractions with applications in Markov processes. <em>IMA Journal of Applied Mathematics</em>, 16(1), 57-71.</p>
</div>
<div class="citation" id="crawfordsuchard2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">CrawfordSuchard2012</a><span class="fn-bracket">]</span></span>
<p>Crawford, F.W. and Suchard, M.A. Transition probabilities for general birth-and-death processes with applications in ecology, genetics, and evolution. <em>Journal of Mathematical Biology</em>, 65(3):553–580.</p>
</div>
<div class="citation" id="kurtz1971" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">Kurtz1971</a><span class="fn-bracket">]</span></span>
<p>Kurtz, T.J., 1971. Limit theorems for sequences of jump Markov processes, <em>Journal of Applied Probability</em>, 8(2):344–356.</p>
</div>
<div class="citation" id="rossetal2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">RossEtAl2009</a><span class="fn-bracket">]</span></span>
<p>Ross, J. V., Pagendam, D. E., &amp; Pollett, P. K. (2009). On parameter estimation in population models II: multi-dimensional processes and transient dynamics. <em>Theoretical Population Biology</em>, 75(2-3), 123-132.</p>
</div>
<div class="citation" id="allen2008" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">Allen2008</a><span class="fn-bracket">]</span></span>
<p>Allen, L. J. (2008). An introduction to stochastic epidemic models. In <em>Mathematical Epidemiology</em> (pp. 81-130). Springer, Berlin, Heidelberg.</p>
</div>
<div class="citation" id="rossetal2006" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">RossEtAl2006</a><span class="fn-bracket">]</span></span>
<p>Ross, J. V., Taimre, T., &amp; Pollett, P. K. (2006). On parameter estimation in population models. <em>Theoretical Population Biology</em>, 70(4), 498-510.</p>
</div>
<div class="citation" id="guttorp1991" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">Guttorp1991</a><span class="fn-bracket">]</span></span>
<p>Guttorp, P., 1991.  Statistical inference for branching processes, Vol. 122. Wiley-Interscience.</p>
</div>
<div class="citation" id="davisonetal2021" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">DavisonEtAl2021</a><span class="fn-bracket">]</span></span>
<p>Davison, A.C., Hautphenne, S. and Kraus, A., 2021. Parameter estimation for discretely observed linear birth‐and‐death processes. <em>Biometrics</em>, 77(1), pp.186-196.</p>
</div>
<div class="citation" id="butler2007" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">Butler2007</a><span class="fn-bracket">]</span></span>
<p>Butler, R.W., 2007.  Saddlepoint approximations with applications (Vol. 22). Cambridge University Press.</p>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="simulation.html" class="btn btn-neutral float-left" title="Simulation Algorithms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="estimation.html" class="btn btn-neutral float-right" title="Parameter Estimation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Sophie Hautphenne and Brendan Patch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>