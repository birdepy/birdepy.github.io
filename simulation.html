<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulation Algorithms &mdash; BirDePy 0.0.10 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/Birdepy_favicon_3.png"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=d019515e"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Transition Probabilities" href="probabilities.html" />
    <link rel="prev" title="Birth-and-death Processes" href="processes.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="index.html">
            
              <img src="_static/Birdepy_logo_1_resized.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Theoretical Background</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="processes.html">Birth-and-death Processes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="processes.html#custom-models">Custom Models</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulation Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#exact">Exact</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tau-leaping"><span class="math notranslate nohighlight">\(\tau\)</span> leaping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#midpoint-approximation">Midpoint approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#galton-watson-approximation">Galton–Watson approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reproducibility">Reproducibility</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="probabilities.html">Transition Probabilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#matrix-exponential">Matrix exponential</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#uniformization">Uniformization</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#erlangization">Erlangization</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#inverse-laplace-transform">Inverse Laplace transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#diffusion-approximation">Diffusion approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#ornstein-uhlenbeck-approximation">Ornstein–Uhlenbeck approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#galton-watson-approximation">Galton–Watson approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#simulation">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="probabilities.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="estimation.html">Parameter Estimation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#direct-numerical-maximization">Direct Numerical Maximization</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#expectation-maximization">Expectation Maximization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="estimation.html#expectation-step-techniques">Expectation Step Techniques</a></li>
<li class="toctree-l3"><a class="reference internal" href="estimation.html#acceleration">Acceleration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#least-squares-estimation">Least Squares Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#approximate-bayesian-computation">Approximate Bayesian Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="estimation.html#customized-distance">Customized Distance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#known-parameters">Known Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#parameter-constraints">Parameter Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#confidence-regions">Confidence Regions</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#continuously-observed-data">Continuously Observed Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="estimation.html#optimization-options">Optimization Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="forecasting.html">Forecasting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Core Functions API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_probability.html">birdepy.probability()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy.probability"><code class="docutils literal notranslate"><span class="pre">probability()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-da">birdepy.probability(method=’da’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_da.probability_da"><code class="docutils literal notranslate"><span class="pre">probability_da()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-erlang">birdepy.probability(method=’Erlang’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_Erlang.probability_Erlang"><code class="docutils literal notranslate"><span class="pre">probability_Erlang()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-expm">birdepy.probability(method=’expm’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_expm.probability_expm"><code class="docutils literal notranslate"><span class="pre">probability_expm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-gwa">birdepy.probability(method=’gwa’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_gwa.probability_gwa"><code class="docutils literal notranslate"><span class="pre">probability_gwa()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-gwasa">birdepy.probability(method=’gwasa’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_gwasa.probability_gwasa"><code class="docutils literal notranslate"><span class="pre">probability_gwasa()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-ilt">birdepy.probability(method=’ilt’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_ilt.probability_ilt"><code class="docutils literal notranslate"><span class="pre">probability_ilt()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-oua">birdepy.probability(method=’oua’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_oua.probability_oua"><code class="docutils literal notranslate"><span class="pre">probability_oua()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-sim">birdepy.probability(method=’sim’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_sim.probability_sim"><code class="docutils literal notranslate"><span class="pre">probability_sim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_probability.html#birdepy-probability-method-uniform">birdepy.probability(method=’uniform’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_probability.html#birdepy.probability_uniform.probability_uniform"><code class="docutils literal notranslate"><span class="pre">probability_uniform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_estimate.html">birdepy.estimate()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy.estimate"><code class="docutils literal notranslate"><span class="pre">estimate()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-abc">birdepy.estimate(framework=’abc’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_abc.discrete_est_abc"><code class="docutils literal notranslate"><span class="pre">discrete_est_abc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-dnm">birdepy.estimate(framework=’dnm’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_dnm.discrete_est_dnm"><code class="docutils literal notranslate"><span class="pre">discrete_est_dnm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-em">birdepy.estimate(framework=’em’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_em.discrete_est_em"><code class="docutils literal notranslate"><span class="pre">discrete_est_em()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-framework-lse">birdepy.estimate(framework=’lse’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_lse.discrete_est_lse"><code class="docutils literal notranslate"><span class="pre">discrete_est_lse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_estimate.html#birdepy-estimate-scheme-continuous">birdepy.estimate(scheme=’continuous’)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_estimate.html#birdepy.interface_dnm.continuous_est_dnm"><code class="docutils literal notranslate"><span class="pre">continuous_est_dnm()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_simulate_discrete.html">birdepy.simulate.discrete()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_simulate_discrete.html#birdepy.simulate.discrete"><code class="docutils literal notranslate"><span class="pre">discrete()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_simulate_continuous.html">birdepy.simulate.continuous()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_simulate_continuous.html#birdepy.simulate.continuous"><code class="docutils literal notranslate"><span class="pre">continuous()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_forecast.html">birdepy.forecast()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_forecast.html#birdepy.forecast"><code class="docutils literal notranslate"><span class="pre">forecast()</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">CUDA Functions API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_cuda_simulate.html">birdepy.gpu_functions.discrete()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_cuda_simulate.html#birdepy.gpu_functions.discrete"><code class="docutils literal notranslate"><span class="pre">discrete()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_cuda_probabilities.html">birdepy.gpu_functions.probability()</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_cuda_probabilities.html#birdepy.gpu_functions.probability"><code class="docutils literal notranslate"><span class="pre">probability()</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Bug Reports and Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id1">0.0.26</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id2">0.0.12</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id3">0.0.11</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id4">0.0.10</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id5">0.0.9</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id6">0.0.8</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id7">0.0.7</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id8">0.0.6</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id9">0.0.5</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id10">0.0.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id11">0.0.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id12">0.0.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="release_notes.html#id13">0.0.1</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BirDePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Simulation Algorithms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/simulation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="simulation-algorithms">
<h1>Simulation Algorithms<a class="headerlink" href="#simulation-algorithms" title="Permalink to this heading"></a></h1>
<p>A few exceptions aside, explicit expressions for quantities of interest such as the probability distribution, or the expected value, of the population size of a general birth-and-death process at a given time, do not exist. By providing many examples of possible outcomes,
Monte Carlo simulation can allow interesting questions related to these processes to be examined.
Simulation can also be used to compare the performance of other tools, such as those used for parameter estimation, by providing synthetic data for the tools to be tested on.
Last, but not least, some parameter estimation techniques directly rely on simulated sample paths to generate estimates.</p>
<p>Simulation of a birth-and-death process can be continuous or discrete. The goal of <em>continuous</em> simulation is
to obtain a sequence of times at which the process transitions, together with the corresponding sequence of states the process transitions into.
In a continuous simulation, the output provides sufficient information to recover the state of the process at any time within the simulation horizon.
This is desirable since the output contains enough information for a user to know whether certain events have occurred, for example whether the process has crossed a certain boundary by a certain time.
In contrast, the goal of <em>discrete</em> simulation is to obtain samples of a birth-and-death process at pre-specified observation times.
In this case, the state of the process at those observation times is the output.
An advantage of discrete simulation is that the same observation times can be specified for each sample path so that they can be combined together to find, for example, the expected value or variance of a process as a function of time.</p>
<section id="exact">
<h2>Exact<a class="headerlink" href="#exact" title="Permalink to this heading"></a></h2>
<p>Given an initial population size <span class="math notranslate nohighlight">\(z_0\)</span>, to perform continuous simulation of a birth-and-death process over the interval <span class="math notranslate nohighlight">\([0,t]\)</span>, initialize <span class="math notranslate nohighlight">\(j:=0\)</span>, <span class="math notranslate nohighlight">\(t_0:=0\)</span>, and then repeat these steps:</p>
<ol class="arabic simple">
<li><p>Generate an outcome <span class="math notranslate nohighlight">\(\Delta\)</span> of an exponentially distributed random variable with mean <span class="math notranslate nohighlight">\((\lambda_{z_j}+\mu_{z_j})^{-1}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(t_j+\Delta\le t\)</span>, set <span class="math notranslate nohighlight">\(t_{j+1}:=t_j+\Delta\)</span>; otherwise stop.</p></li>
<li><p>With probability <span class="math notranslate nohighlight">\(\lambda_{z_j}/(\lambda_{z_j}+\mu_{z_j})\)</span> set <span class="math notranslate nohighlight">\(z_{j+1}:=z_j+1\)</span>; otherwise set <span class="math notranslate nohighlight">\(z_{j+1}:=z_j-1\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(j:=j+1\)</span>.</p></li>
</ol>
<p>See <a class="reference internal" href="api_simulate_continuous.html#birdepy-simulate-continuous"><span class="std std-ref">birdepy.simulate.continuous()</span></a> for an implementation of this algorithm.</p>
<p>Discrete simulation proceeds in a similar fashion.
Given an initial population size <span class="math notranslate nohighlight">\(z_0\)</span>, to simulate a birth-and-death process at the time points <span class="math notranslate nohighlight">\(t_0&lt;t_1&lt;\dots &lt;t_n\)</span>, initialize <span class="math notranslate nohighlight">\(j:=1\)</span>, <span class="math notranslate nohighlight">\(s:=t_0+\Delta\)</span> where <span class="math notranslate nohighlight">\(\Delta\)</span> is an outcome of an exponentially distributed random variable with mean <span class="math notranslate nohighlight">\((\lambda_{z}+\mu_{z})^{-1}\)</span>, and <span class="math notranslate nohighlight">\(z:=z_0\)</span>, and then repeat these steps:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>While <span class="math notranslate nohighlight">\(s \le t_j\)</span>:</dt><dd><ol class="arabic simple">
<li><p>With probability <span class="math notranslate nohighlight">\(\lambda_{z}/(\lambda_{z}+\mu_{z})\)</span> set <span class="math notranslate nohighlight">\(z:=z+1\)</span>; otherwise set <span class="math notranslate nohighlight">\(z:=z-1\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(s := s +\Delta\)</span> where <span class="math notranslate nohighlight">\(\Delta\)</span> is an outcome of an exponentially distributed random variable with mean <span class="math notranslate nohighlight">\((\lambda_{z}+\mu_{z})^{-1}\)</span>.</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>Set <span class="math notranslate nohighlight">\(z_{j}:=z\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(j&lt;n\)</span> set <span class="math notranslate nohighlight">\(j:=j+1\)</span>; otherwise stop.</p></li>
</ol>
<p>Observe that <span class="math notranslate nohighlight">\(t_j\)</span> has a different interpretation depending on whether continuous or discrete simulation is being performed.
It is thought within the probability community that this <em>exact</em> approach to simulation of CTMCs was first considered by Joseph L. Doob and his collaborators around 1945.
To our knowledge, the first implementation on a computer is mentioned in <a class="reference internal" href="#kendall1950" id="id1"><span>[Kendall1950]</span></a>, and the algorithm was then popularized more widely in <a class="reference internal" href="#gillespie1977" id="id2"><span>[Gillespie1977]</span></a>.</p>
<p>See <a class="reference internal" href="api_simulate_discrete.html#birdepy-simulate-discrete"><span class="std std-ref">birdepy.simulate.discrete()</span></a> (with <cite>method</cite> set to ‘exact’) for an implementation of this algorithm.</p>
</section>
<section id="tau-leaping">
<h2><span class="math notranslate nohighlight">\(\tau\)</span> leaping<a class="headerlink" href="#tau-leaping" title="Permalink to this heading"></a></h2>
<p>A well-known drawback of exact simulation algorithms is that they may take considerable computational time to produce sample paths.
An alternative <em>approximate</em> simulation method for population processes known as <em>tau-leaping</em>, introduced by <a class="reference internal" href="#gillespie2001" id="id3"><span>[Gillespie2001]</span></a>, allows the user to trade accuracy for speed.
This algorithm partitions time into intervals of predetermined constant length <span class="math notranslate nohighlight">\(\tau\)</span>.
Conditional on <span class="math notranslate nohighlight">\(Z(0)=z\)</span> at the start of an interval, the state of <span class="math notranslate nohighlight">\(Z(\tau)\)</span> is approximated by the difference of two Poisson distributed random variables <span class="math notranslate nohighlight">\(\mathfrak L\)</span> and <span class="math notranslate nohighlight">\(\mathfrak M\)</span> which are respectively intended to approximate the total number of births and deaths that occur within the interval.
Given an initial population size <span class="math notranslate nohighlight">\(z_0\)</span>, the basic <em>Euler</em> form of the algorithm can be used to perform discrete simulation by initializing <span class="math notranslate nohighlight">\(j:=1\)</span>, <span class="math notranslate nohighlight">\(s:=t_0+\tau\)</span>, and <span class="math notranslate nohighlight">\(z:=z_0\)</span>, and then repeating these steps:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>While <span class="math notranslate nohighlight">\(s\le t_j\)</span>:</dt><dd><ol class="arabic simple">
<li><p>Set <span class="math notranslate nohighlight">\(z := z +\mathfrak L -\mathfrak M\)</span> where <span class="math notranslate nohighlight">\(\mathfrak L\)</span> and <span class="math notranslate nohighlight">\(\mathfrak M\)</span> are are outcomes of Poisson distributed random variables with respective means <span class="math notranslate nohighlight">\(\lambda_{z}\tau\)</span> and <span class="math notranslate nohighlight">\(\mu_{z}\tau\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(s:=s+\tau\)</span>.</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>Set <span class="math notranslate nohighlight">\(z_{j}:=z\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(j&lt;n\)</span> set <span class="math notranslate nohighlight">\(j:=j+1\)</span>; otherwise stop.</p></li>
</ol>
<p>See <a class="reference internal" href="api_simulate_discrete.html#birdepy-simulate-discrete"><span class="std std-ref">birdepy.simulate.discrete()</span></a> (with <cite>method</cite> set to ‘ea’) for an implementation of this algorithm.</p>
<p>Several variations of this algorithm have been developed which focus primarily on step-size selection and on ensuring that the population size does not go negative during the simulation.</p>
</section>
<section id="midpoint-approximation">
<h2>Midpoint approximation<a class="headerlink" href="#midpoint-approximation" title="Permalink to this heading"></a></h2>
<p>In <a class="reference internal" href="#andersongangulykurtz2011" id="id4"><span>[AndersonGangulyKurtz2011]</span></a> a <em>midpoint</em> variant of the basic algorithm is developed and elegantly analyzed.
The  algorithm is the same as the Euler version described above with the exception that the two Poisson distributed random variables <span class="math notranslate nohighlight">\(\mathfrak L\)</span> and <span class="math notranslate nohighlight">\(\mathfrak M\)</span> have respective means <span class="math notranslate nohighlight">\(\lambda_{z+\rho(z)}\tau\)</span> and <span class="math notranslate nohighlight">\(\mu_{z+\rho(z)}\tau\)</span>, where <span class="math notranslate nohighlight">\(\rho(z)=\frac{1}{2}\tau\big(\lambda_z-\mu_z\big)\)</span> approximates <span class="math notranslate nohighlight">\(\mathbb E [Z(\frac{1}{2}\tau)-Z(0)\,|\,Z(0)=z]\)</span>.
The basic idea here is that determining the number of births and deaths using an approximation to the population size at the midpoint of an interval may increase accuracy relative to using the population size at the beginning of the interval.
This algorithm can provide substantial improvements in accuracy relative to the Euler version at only a minor increase in computational cost.
Both of the above algorithms can be thought of as generating piecewise approximations to a general birth-and-death process, where zero-order approximations of the birth and death rates are utilized within each subinterval.
See <a class="reference internal" href="api_simulate_discrete.html#birdepy-simulate-discrete"><span class="std std-ref">birdepy.simulate.discrete()</span></a> (with <cite>method</cite> set to ‘ma’) for an implementation of this algorithm.</p>
</section>
<section id="galton-watson-approximation">
<h2>Galton–Watson approximation<a class="headerlink" href="#galton-watson-approximation" title="Permalink to this heading"></a></h2>
<p>Recently a new approach to perform discrete simulation of a general birth-and-death processes utilizing linear (first-order) approximations of the birth and death rates within each subinterval was proposed in <a class="reference internal" href="#hautphennepatch2021b" id="id5"><span>[HautphennePatch2021b]</span></a>.
This algorithm approximates any birth-and-death process by <em>piecewise-linear</em> birth-and-death processes.
It also uses the fact that a discretely-observed linear birth-and-death process corresponds to a <em>linear fractional Galton–Watson process</em> (see <a class="reference internal" href="#harris1963" id="id6"><span>[Harris1963]</span></a>).
This means that for a linear birth-and-death process <span class="math notranslate nohighlight">\(Z\)</span> with birth rates <span class="math notranslate nohighlight">\(\lambda_z=\lambda z\)</span> and death rates <span class="math notranslate nohighlight">\(\mu_z=\mu z\)</span>, the probability that a family generated by a single individual at time <span class="math notranslate nohighlight">\(0\)</span> ‘becomes extinct’ before time <span class="math notranslate nohighlight">\(\tau\)</span> is given by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\beta_1(\tau) = \left\{\begin{array}{cc} \mu\{\exp\big((\lambda-\mu)\tau\big)-1\}/\{\lambda \exp\big((\lambda-\mu)\tau\big)-\mu\} &amp; \text{if } \lambda\ne \mu, \\
\lambda \tau/(1+\lambda \tau) &amp; \text{if } \lambda = \mu.
\end{array}\right.\end{split}\]</div>
</div></blockquote>
<p>Each family which survives results in <span class="math notranslate nohighlight">\(H\)</span> individuals being present at time <span class="math notranslate nohighlight">\(\tau\)</span>, where <span class="math notranslate nohighlight">\(\mathbb P(H=h) = (1-\beta_2(\tau))\beta_2(\tau)^{h-1}\)</span> with</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\beta_2(\tau) = \left\{ \begin{array}{cc} \lambda\beta_1(\tau)/\mu&amp; \text{if } \lambda\ne \mu, \\
\beta_1(\tau) &amp; \text{if } \lambda = \mu.
\end{array}\right.\end{split}\]</div>
</div></blockquote>
<p>Therefore, given <span class="math notranslate nohighlight">\(\mathring Z(0)=z\)</span>, a realization of <span class="math notranslate nohighlight">\(\mathring Z(\tau)\)</span> can be obtained by generating an outcome of the random variable <span class="math notranslate nohighlight">\(\mathfrak B\)</span> which is binomially distributed with <span class="math notranslate nohighlight">\(z\)</span> trials and success probability <span class="math notranslate nohighlight">\(1-\beta_1(\tau)\)</span> (defined above), and then using the fact that <span class="math notranslate nohighlight">\(\mathring Z(\tau)\)</span> follows a negative binomial distribution with parameters <span class="math notranslate nohighlight">\(\mathfrak B\)</span> and <span class="math notranslate nohighlight">\(1-\beta_2(\tau)\)</span>, that is,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbb P(\mathring Z(t_j) = k\,|\,\mathfrak B) = \binom{k+\mathfrak B-1}{k}\beta_2(\tau)^{\mathfrak B}(1-\beta_2(\tau))^k.\]</div>
</div></blockquote>
<p>So, if <span class="math notranslate nohighlight">\(Z\)</span> is a general birth-and-death process, conditional on <span class="math notranslate nohighlight">\(Z(0)\)</span>, <span class="math notranslate nohighlight">\(Z(\tau)\)</span> can be approximated by <span class="math notranslate nohighlight">\(\mathring Z(\tau)\)</span> by setting the per-individual rates of the approximating linear process <span class="math notranslate nohighlight">\(\mathring Z\)</span> equal to those of <span class="math notranslate nohighlight">\(Z\)</span> at time <span class="math notranslate nohighlight">\(0\)</span>, that is, <span class="math notranslate nohighlight">\(\lambda = \lambda_{Z(0)}/Z(0)\)</span> and <span class="math notranslate nohighlight">\(\mu=\mu_{Z(0)}/Z(0)\)</span>.
Therefore, to obtain an approximate simulation of <span class="math notranslate nohighlight">\((Z(t_j),~j=0,1,\dots,n)\)</span>, initialize <span class="math notranslate nohighlight">\(j:=1\)</span>, <span class="math notranslate nohighlight">\(s:=t_0+\tau\)</span>, and <span class="math notranslate nohighlight">\(z:=z_0\)</span>, and repeat these steps:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>While <span class="math notranslate nohighlight">\(s\le t_j\)</span>:</dt><dd><ol class="lowerroman simple">
<li><p>Set <span class="math notranslate nohighlight">\(\lambda := \lambda_{z}/z\)</span> and <span class="math notranslate nohighlight">\(\mu := \mu_{z}/z\)</span>.</p></li>
<li><p>Generate a binomially distributed random variable <span class="math notranslate nohighlight">\(\mathfrak B\)</span> with success probability <span class="math notranslate nohighlight">\(1-\beta_1(\tau)\)</span> with <span class="math notranslate nohighlight">\(\beta_1(\tau)\)</span> as given above and number of trials <span class="math notranslate nohighlight">\(z\)</span>.</p></li>
<li><p>Generate a negatively binomially distributed random variable <span class="math notranslate nohighlight">\(\mathfrak C\)</span> with success probability <span class="math notranslate nohighlight">\(1-\beta_2(\tau)\)</span> with <span class="math notranslate nohighlight">\(\beta_2(\tau)\)</span> as given above and number of trials <span class="math notranslate nohighlight">\(\mathfrak B\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(z := z +\mathfrak C\)</span> and <span class="math notranslate nohighlight">\(s:=s+\tau\)</span>.</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>Set <span class="math notranslate nohighlight">\(z_j:=z\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(j&lt;n\)</span> set <span class="math notranslate nohighlight">\(j:=j+1\)</span>; otherwise stop.</p></li>
</ol>
<p>This algorithm can be implemented efficiently and is highly accurate.
It also explicitly avoids the possibility of the population size becoming negative during the simulation.
See <a class="reference internal" href="api_simulate_discrete.html#birdepy-simulate-discrete"><span class="std std-ref">birdepy.simulate.discrete()</span></a> (with <cite>method</cite> set to ‘gwa’) for an implementation of this algorithm.</p>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading"></a></h2>
<p>The table below summarizes the discrete simulation methods described on this page, and gives the label used to call them in <a class="reference internal" href="api_simulate_discrete.html#birdepy-simulate-discrete"><span class="std std-ref">birdepy.simulate.discrete()</span></a>.</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">Methods for simulating sample paths of general birth-and-death processes.</span><a class="headerlink" href="#id10" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Label</p></th>
<th class="head"><p>Brief description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Exact</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'exact'</span></code></p></td>
<td><p>Utilizes all jumps of the process.</p></td>
</tr>
<tr class="row-odd"><td><p>Euler approximation</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'ea'</span></code></p></td>
<td><p>Population changes between <span class="math notranslate nohighlight">\(\tau\)</span>-sized intervals governed by Poisson random variables with parameters depending on population sizes at beginning of intervals.</p></td>
</tr>
<tr class="row-even"><td><p>Midpoint approximation</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'ma'</span></code></p></td>
<td><p>Population changes between <span class="math notranslate nohighlight">\(\tau\)</span>-sized intervals governed by Poisson random variables with parameters depending on estimate of population sizes at midpoints of intervals.</p></td>
</tr>
<tr class="row-odd"><td><p>Galton–Watson approximation</p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">'gwa'</span></code></p></td>
<td><p>Population changes between <span class="math notranslate nohighlight">\(\tau\)</span>-sized intervals governed by linear birth-and-death processes with parameters depending on population sizes at beginning of intervals.</p></td>
</tr>
</tbody>
</table>
<p>These methods are also described in detail in <a class="reference internal" href="#hautphennepatch2021a" id="id7"><span>[HautphennePatch2021a]</span></a> and <a class="reference internal" href="#hautphennepatch2021b" id="id8"><span>[HautphennePatch2021b]</span></a>, which can be downloaded <a class="reference external" href="https://github.com/birdepy/paper/blob/main/birdepy.pdf">here</a> and <a class="reference external" href="https://github.com/birdepy/paper/blob/main/psdbdp_simulation.pdf">here</a>. If you use BirDePy for published research, then please cite these papers.</p>
</section>
<section id="reproducibility">
<h2>Reproducibility<a class="headerlink" href="#reproducibility" title="Permalink to this heading"></a></h2>
<p>BirDePy uses <a class="reference external" href="https://numpy.org/doc/1.21/reference/random/index.html?highlight=random#module-numpy.random">numpy.random</a> to generate random numbers.
Functions which utilize random numbers have a seed parameter that can be used for reproducibility.
The seed parameters accept either an integer number or a <a class="reference external" href="https://numpy.org/doc/1.21/reference/random/generator.html#numpy.random.Generator">Generator</a> as input.
Sometimes a script uses multiple functions and the user only wishes to specify a single seed.
The recommended way to handle this situation is to create a generator <cite>rng</cite> with the preferred seed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">seed</span> <span class="o">=</span> <span class="mi">2021</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
</pre></div>
</div>
<p>The generator can then be passed to all of the functions which have a seed parameter.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">birdepy</span> <span class="k">as</span> <span class="nn">bd</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">simulate</span><span class="o">.</span><span class="n">discrete</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Poisson&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">seed</span><span class="o">=</span><span class="n">rng</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="kendall1950" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Kendall1950</a><span class="fn-bracket">]</span></span>
<p>Kendall, D.G., 1950. An artificial realization of a simple “birth-and-death” process. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, 12(1), pp.116-119.</p>
</div>
<div class="citation" id="gillespie1977" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Gillespie1977</a><span class="fn-bracket">]</span></span>
<p>Gillespie, D.T., 1977. Exact stochastic simulation of coupled chemical reactions. <em>The Journal of Physical Chemistry</em>, 81(25), pp.2340-2361.</p>
</div>
<div class="citation" id="gillespie2001" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Gillespie2001</a><span class="fn-bracket">]</span></span>
<p>Gillespie, D.T., 2001. Approximate accelerated stochastic simulation of chemically reacting systems. <em>The Journal of Chemical Physics</em>, 115(4), pp.1716-1733.</p>
</div>
<div class="citation" id="hautphennepatch2021b" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HautphennePatch2021b<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id8">2</a>)</span>
<p>Hautphenne, S. and Patch, B., 2021. Simulating population-size-dependent birth-and-death processes using CUDA and piecewise approximations. In <em>Proceedings of the International Congress on Modelling and Simulation 2021</em>. (to appear)</p>
</div>
<div class="citation" id="andersongangulykurtz2011" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">AndersonGangulyKurtz2011</a><span class="fn-bracket">]</span></span>
<p>Anderson, D.F., Ganguly, A. and Kurtz, T.G., 2011. Error analysis of tau-leap simulation methods. <em>The Annals of Applied Probability</em>, 21(6), pp.2226-2262.</p>
</div>
<div class="citation" id="harris1963" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">Harris1963</a><span class="fn-bracket">]</span></span>
<p>Harris, T. E. (1963). The theory of branching processes (Vol. 6). Berlin: Springer.</p>
</div>
<div class="citation" id="hautphennepatch2021a" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">HautphennePatch2021a</a><span class="fn-bracket">]</span></span>
<p>Hautphenne, S., and Patch, B., (2021). Birth-and-death Processes in Python: The BirDePy Package.</p>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="processes.html" class="btn btn-neutral float-left" title="Birth-and-death Processes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="probabilities.html" class="btn btn-neutral float-right" title="Transition Probabilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Sophie Hautphenne and Brendan Patch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>